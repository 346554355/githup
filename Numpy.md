# 1.1、numpy-ndarray
## 1.ndarray的特性
### 多维性


```python
import numpy as np
```


```python
arr = np.array(5) # 创建0维度的ndarray数组
print(arr)
print('arr的维度:',arr.ndim)  # 数组的维度number of dimensions   arr
print('数组的形状:',arr.shape)
print('元素的个数:',arr.size)
print('元素的数据类型',arr.dtype)
```

    5
    arr的维度: 0
    数组的形状: ()
    元素的个数: 1
    元素的数据类型 int64
    


```python
arr = np.array([1,2,3])  # 创建1维度的ndarray数组    arr
print(arr)
print('数组的维度:',arr.ndim)  # 数组的维度number of dimensions
print('数组的形状:',arr.shape)
print('元素的个数:',arr.size)
print('元素的数据类型',arr.dtype)
```

    [1 2 3]
    数组的维度: 1
    数组的形状: (3,)
    元素的个数: 3
    元素的数据类型 int64
    


```python
arr = np.array([[1,2,3],[4,5,6]])  # 创建2维度的ndarray数组    arr
print(arr)
print('数组的维度:',arr.ndim)   # 数组的维度number of dimensions
print('数组的形状:',arr.shape)
print('元素的个数:',arr.size)
print('元素的数据类型',arr.dtype)
```

    [[1 2 3]
     [4 5 6]]
    数组的维度: 2
    数组的形状: (2, 3)
    元素的个数: 6
    元素的数据类型 int64
    

### 同质性


```python
arr = np.array([1,"hello"])  # 不同的数据类型会被强制转换成相同的数据类型
print(arr)
print('arr的维度:',arr.ndim)
print('数组的形状:',arr.shape)
print('元素的个数:',arr.size)
print('元素的数据类型',arr.dtype)
```

    ['1' 'hello']
    arr的维度: 1
    数组的形状: (2,)
    元素的个数: 2
    元素的数据类型 <U21
    


```python
arr = np.array([1,2.5])    #  不同的数据类型会被强制转换成相同的数据类型
print(arr)
print('arr的维度:',arr.ndim)
print('数组的形状:',arr.shape)
print('元素的个数:',arr.size)
print('元素的数据类型',arr.dtype)
```

    [1.  2.5]
    arr的维度: 1
    数组的形状: (2,)
    元素的个数: 2
    元素的数据类型 float64
    

## 2.ndarray的属性


```python
arr = np.array(1)
print(arr)
print('数组的形状:',arr.shape)
print('数组的维度:',arr.ndim)
print('数组元素的个数:',arr.size)
print('元素的数据类型:',arr.dtype)
print('元素的转置:',arr.T)
```

    1
    数组的形状: ()
    数组的维度: 0
    数组元素的个数: 1
    元素的数据类型: int64
    元素的转置: 1
    


```python
arr = np.array([1,2.5,3])
print(arr)
print('数组的形状:',arr.shape)
print('数组的维度:',arr.ndim)
print('数组元素的个数:',arr.size)
print('元素的数据类型:',arr.dtype)
print('元素的转置:',arr.T)
```

    [1.  2.5 3. ]
    数组的形状: (3,)
    数组的维度: 1
    数组元素的个数: 3
    元素的数据类型: float64
    元素的转置: [1.  2.5 3. ]
    


```python
arr = np.array([[1,2,3],[4,5,6]])
print(arr)
print('数组的形状:',arr.shape)
print('数组的维度:',arr.ndim)
print('数组元素的个数:',arr.size)
print('元素的数据类型:',arr.dtype)
print('元素的转置:',arr.T)
```

    [[1 2 3]
     [4 5 6]]
    数组的形状: (2, 3)
    数组的维度: 2
    数组元素的个数: 6
    元素的数据类型: int64
    元素的转置: [[1 4]
     [2 5]
     [3 6]]
    

## 3.ndarray的创建


```python
#基础的创建方法
list1 = [4,5,6]
arr = np.array(list1,dtype=np.float64)   # 强制转换为浮点数
print(arr.ndim)    # 属性
print(arr)
```

    1
    [4. 5. 6.]
    


```python
# copy
arr1 = np.copy(arr)   # 复制上面的arr,元素跟原始的数组相同，但是不是同一个数组了
print(arr1)
arr1[0] = 8   # 修改arr1第一个数值4改为8
print(arr1)
print(arr)    # 不会改变arr的数值
```

    [4. 5. 6.]
    [8. 5. 6.]
    [4. 5. 6.]
    


```python
# 预定义形状
# 全0  全1  未初始化  固定值
# 全0
arr = np.zeros((2,3))  # 创建一个2行3列的
print(arr) 
print(arr.dtype)
```

    [[0. 0. 0.]
     [0. 0. 0.]]
    float64
    


```python
arr = np.zeros((20,),dtype=int)  
print(arr) 
```

    [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
    


```python
# 全1
arr = np.ones((5,8),dtype=int)  
print(arr) 
```

    [[1 1 1 1 1 1 1 1]
     [1 1 1 1 1 1 1 1]
     [1 1 1 1 1 1 1 1]
     [1 1 1 1 1 1 1 1]
     [1 1 1 1 1 1 1 1]]
    


```python
# 未初始化
arr = np.empty((4,3))
print(arr)
```

    [[1.13216400e-311 2.81617418e-322 0.00000000e+000]
     [0.00000000e+000 0.00000000e+000 5.74084271e+169]
     [5.20365780e-090 2.78857412e+179 5.41472271e-067]
     [1.58714115e-047 6.48224659e+170 4.93432906e+257]]
    


```python
# 固定值
arr = np.full((3,4),2025)
print(arr)
```

    [[2025 2025 2025 2025]
     [2025 2025 2025 2025]
     [2025 2025 2025 2025]]
    


```python
# 像某个形状
arr1 = np.zeros_like(arr)
print(arr1)
arr1 = np.empty_like(arr)
print(arr1)
arr1 = np.ones_like(arr)
print(arr1)
arr1 = np.full_like(arr,2026)
print(arr1)
```

    [[0 0 0 0]
     [0 0 0 0]
     [0 0 0 0]]
    [[      2291525448072                  64                   0
                        0]
     [  31525592528584704 3832619570103215206 7292511292990120805
      3630517267636566320]
     [4050206353479984689 7162184869835192118 4063484249069872740
      7089568934313288753]]
    [[1 1 1 1]
     [1 1 1 1]
     [1 1 1 1]]
    [[2026 2026 2026 2026]
     [2026 2026 2026 2026]
     [2026 2026 2026 2026]]
    


```python
# 等差数列 1 2 3 4 5
arr = np.arange(1,12,2)   # 1代表开始(start)  12代表结束(end)  2代表步长(step)
print(arr)
arr = np.arange(2,12,3)   # 2代表开始(start)  12代表结束(end)  3代表步长(step)
print(arr)
arr = np.arange(1,50,5)   # 1代表开始(start)  50代表结束(end)  5代表步长(step)
print(arr)
```

    [ 1  3  5  7  9 11]
    [ 2  5  8 11]
    [ 1  6 11 16 21 26 31 36 41 46]
    


```python
# 等间隔数列
arr = np.linspace(0,10,3)  # 0代表开始(start)  10代表结束(end)  3代表个数
print(arr)

```

    [ 0.  5. 10.]
    


```python
# 练习
arr = np.linspace(0,100,5,dtype=int)  # 0代表开始(start)  100代表结束(end)  5代表个数
print(arr)
arr = np.arange(0,101,25)   # 0代表开始(start)  100代表结束(end)  5代表个数
print(arr)
```

    [  0  25  50  75 100]
    [  0  25  50  75 100]
    


```python
# 对数间隔列
arr = np.linspace(0,4,3)   # 计算结果
print(arr)
arr = np.logspace(0,4,3,base=2)  # 通过上面的计算结果在进行计算
print(arr)
arr = np.logspace(0,4,3)   # 得出结果是结果的几次方
print(arr)
```

    [0. 2. 4.]
    [ 1.  4. 16.]
    [1.e+00 1.e+02 1.e+04]
    


```python
# 特殊矩阵
# 单位矩阵:主对角线上的数字为1，其他的数字为0
arr = np.eye(3,4,dtype=int)  # 创建3行4列的整数矩阵
print(arr)
```

    [[1 0 0 0]
     [0 1 0 0]
     [0 0 1 0]]
    


```python
# 对角矩阵:主对角线上非零的数字为0，其他的数字为0
arr = np.diag([1,2,3])  # 创建对角线的数字为1,2,3,其他数字为0
print(arr)
arr1 = np.diag([5,1,2,3])  # 创建对角线的数字为5,1,2,3，其他数字为0
print(arr1)
```

    [[1 0 0]
     [0 2 0]
     [0 0 3]]
    [[5 0 0 0]
     [0 1 0 0]
     [0 0 2 0]
     [0 0 0 3]]
    


```python
# 随机数组的生成
# 生成0-1之间的浮点数(均匀分布)
arr = np.random.rand(2,3)    # 创建2行3列的随机数组范围为0-1,数值为浮点数
print(arr)

```

    [[0.57066991 0.40686256 0.69010598]
     [0.5144529  0.18814733 0.30054569]]
    


```python
# 生成指定范围区间的随机浮点数
arr = np.random.uniform(3,6,(2,3))  # 创建2行3列的数组范围为3-6之间，数值为浮点数
print(arr)
```

    [[3.1331522  4.48078519 3.32649989]
     [4.10209776 3.49287278 5.41095336]]
    


```python
# 生成指定范围区间的随机整数
arr = np.random.randint(3,10,(2,3))  # 创建2行3列的数组范围为3-10之间，数值为整数
print(arr)
```

    [[5 7 6]
     [5 4 9]]
    


```python
# 生成随机整数(正态分布),意思就是两边小，中间大(-3到3之间)
arr = np.random.randn(2,3)
print(arr)
```

    [[-0.22425429  0.60750382  0.00626427]
     [-1.59868914 -1.64273815  1.10805367]]
    


```python
# 设置随机种子
np.random.seed(20)
arr = np.random.randint(1,10,(2,5))  # 创建2行5列的数组范围为1-10之间，数值为整数
print(arr)
```

    [[4 5 7 8 3]
     [1 7 9 6 4]]
    

## 4.ndarray的数据类型
###  布尔类型  bool
### 整点类型 int uint
### 浮点数 float
### 复数 complex


```python
import numpy as np
arr = np.array([1,0,129,0],dtype=np.uint)
print(arr)
```

    [  1   0 129   0]
    

## 5.ndarray的索引与切片
### 1维数组的索引与切片


```python
import numpy as np
arr = np.random.randint(1,100,20)  # 随机生成1-100的数组，个数为20个
print(arr)
```

    [17 63 17  8 99  7 27 14 76 59 26  4 75 76 62 78 84 58 95 33]
    


```python
print(arr[0])   # 打印第一个数据，0代表第一个
```

    17
    


```python
print(arr[:])   # 获取全部的数据
```

    [17 63 17  8 99  7 27 14 76 59 26  4 75 76 62 78 84 58 95 33]
    


```python
print(arr[2:5])  # 获取第三3到第5个个数据，也就是开始第一个数据是2+1，结束是5，切片的时候记得是左边加1，右边不加
```

    [17  8 99]
    


```python
print(arr[slice(2,15,3)])   # 获取第3个到第15个，隔3个获取一个
```

    [17  7 76  4 62]
    


```python
print(arr[arr>10])  # 获取大于10的数据，也就是布尔索引
```

    [17 63 17 99 27 14 76 59 26 75 76 62 78 84 58 95 33]
    


```python
print(arr[(arr>10) & (arr<30)])  # 获取大于10或小于30的数据，也就是布尔索引
```

    [17 17 27 14 26]
    

### 2维数组的索引与切片


```python
arr = np.random.randint(1,100,(4,8))  # 随机生成4行8列1-100的数组
print(arr)
```

    [[11  7 76 19  4 78 18 44]
     [17 19 80 91 60 72 76 30]
     [46  7 64 79 25 19 94 34]
     [79 43 95  4 19 71 53 23]]
    


```python
print(arr[2,3])  # 精确索引，获取第3行第4个数据，代码的第一个是0，所以记得加1就行
```

    79
    


```python
print(arr[1,2:5])  # 获取第2行第3个到第5个的数据，切片的时候记得是左边加1，右边不加
```

    [80 91 60]
    


```python
print(arr[arr>50])  # 获取大于50的数据
```

    [76 78 80 91 60 72 76 64 79 94 79 95 71 53]
    


```python
print(arr[arr>50])  # 获取大于50的数据
```

    [76 78 80 91 60 72 76 64 79 94 79 95 71 53]
    


```python
print(arr[2][arr[2]>50])  # 获取第3行大于50的数据
```

    [64 79 94]
    


```python
print(arr[:,3][arr[:,3]>50])  # 获取第4列大于50的数据
```

    [91 79]
    

## 6.ndarray的运算


```python
# 1维数组的算术运算
a = np.array([1,2,3])
b = np.array([4,5,6])
print(a + b)   # 加法
print(a - b)   # 减法
print(a * b )  # 乘法
print(a / b)   # 除法
print( a ** 2)  # 平方
```

    [5 7 9]
    [-3 -3 -3]
    [ 4 10 18]
    [0.25 0.4  0.5 ]
    [1 4 9]
    


```python
# 原生的python的运算,写起来就稍微麻烦一点，需要写一个for循环
c = [1,2,3]
d = [4,5,6]
for i in range(len(c)):
    d[i] = d[i] + c[i]
print(d)
```

    [5, 7, 9]
    


```python
# 2维数组的算术运算
a = np.array([[1,2,3],[4,5,6],[7,8,9]])
b = np.array([[4,5,6],[7,8,9],[1,2,3]])
print(a + b)   # 加法
print(a - b)   # 减法
print(a * b )  # 乘法
print(a / b)   # 除法
print( a ** 2)  # a的2平方
```

    [[ 5  7  9]
     [11 13 15]
     [ 8 10 12]]
    [[-3 -3 -3]
     [-3 -3 -3]
     [ 6  6  6]]
    [[ 4 10 18]
     [28 40 54]
     [ 7 16 27]]
    [[0.25       0.4        0.5       ]
     [0.57142857 0.625      0.66666667]
     [7.         4.         3.        ]]
    [[ 1  4  9]
     [16 25 36]
     [49 64 81]]
    


```python
# 数组与标量之间的算术运算
a = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(a + 3)  # 把a里面的数据，都加上3
print(a * 3)  # 把a里面的数据，都乘以3
```

    [[ 4  5  6]
     [ 7  8  9]
     [10 11 12]]
    [[ 3  6  9]
     [12 15 18]
     [21 24 27]]
    


```python
# 广播机制  1.获取形状    2.是否广播
# 同一维度:相同、1
a = np.array([1,2,3])    # 数组为1行3列
b = np.array([[4],[5],[6]])   # 数组为3行1列
"""
下面是扩展说明怎么a+b的
a 
1 2 3
1 2 3
1 2 3
b
4 4 4
5 5 5
6 5 5

"""
print(a + b)  
print(b - a)
```

    [[5 6 7]
     [6 7 8]
     [7 8 9]]
    [[3 2 1]
     [4 3 2]
     [5 4 3]]
    


```python
# 下面的案例就是形状不同，所以就不能广播，就会报错
a = np.array([1,2,3])    # 数组为1行3列
b = np.array([4,5])   # 数组为1行2列
print(a + b)
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    Cell In[49], line 4
          2 a = np.array([1,2,3])    # 数组为1行3列
          3 b = np.array([4,5])   # 数组为1行2列
    ----> 4 print(a + b)
    

    ValueError: operands could not be broadcast together with shapes (3,) (2,) 



```python
# 矩阵运算
a = np.array([[1,2,3],[4,5,6],[7,8,9]])  # 3行3列的数组
b = np.array([[4,5,6],[7,8,9],[1,2,3]])  # 3行3列的数组
"""
扩展说明怎么乘法的
a
1 2 3
4 5 6
7 8 9
b
4 5 6
7 8 9
1 2 3

普通乘法就是对应的a里面的第1行第1个乘以b里面的第1行第1个，以此类推
"""
print(a * b)
print(a @ b)
"""
矩阵乘法结果说明比如print(a @ b)结果里面的72是怎么来的呢
找到结果是第2行2列，那就先找到a数组里面的第2行是4 5 6
              在找到b数组里面的第2列s是5 8 2 
                然后再对应相乘 4*5+5*8+6*2=72
"""
```

    [[ 4 10 18]
     [28 40 54]
     [ 7 16 27]]
    [[ 21  27  33]
     [ 57  72  87]
     [ 93 117 141]]
    




    '\n矩阵乘法结果说明比如print(a @ b)结果里面的72是怎么来的呢\n找到结果是第2行2列，那就先找到a数组里面的第2行是4 5 6\n              在找到b数组里面的第2列s是5 8 2 \n                然后再对应相乘 4*5+5*8+6*2=72\n'



# 1-2numpy中的常用函数
## 1.基本数学函数


```python
import numpy as np
# 计算平方根
print(np.sqrt(9))
print(np.sqrt([1,4,9]))
arr = np.array([1,25,81])
print(np.sqrt(arr))
```

    3.0
    [1. 2. 3.]
    [1. 5. 9.]
    


```python
# 计算指数  e^x = y   与下面是相互对应的
print(np.exp(1))
```

    2.718281828459045
    


```python
# 计算自然对数  lu y = x   与上面是相互对应的
print(np.log(2.71))
```

    0.9969486348916096
    


```python
# 计算正弦值   余弦值
print(np.sin(np.pi/2))
print(np.cos(np.pi))
```

    1.0
    -1.0
    


```python
# 计算绝对值
arr= np.array([-1,1,2,-3])
print(np.abs(arr))
```

    [1 1 2 3]
    


```python
# 计算a的b次幂
arr= np.array([-1,1,2,-3])
print(np.power(arr,3))
```

    [ -1   1   8 -27]
    


```python
# 计算四舍五入
print(np.round([3.2,4.5,8.1,9.6]))
```

    [ 3.  4.  8. 10.]
    


```python
# 计算向上取整  向下取整
arr = np.array(([1.6,25.1,81.7]))
print(np.ceil(arr))   # 向上取整
print(np.floor(arr))  # 向下取整
```

    [ 2. 26. 82.]
    [ 1. 25. 81.]
    


```python
# 检测缺失值NaN
np.isnan([1,2,np.nan,3])
```




    array([False, False,  True, False])



## 2.统计函数
## 求和，计算平均值，计算中位数，标准差，方差
## 查找最大值，最小值
## 计算分位数，累积和，累积积(乘法)


```python
arr = np.random.randint(1,20,8)
print(arr)
```

    [ 2 13  3 16  3 18  5 14]
    


```python
# 求和
print(np.sum([1,2,3]))  # 结果是三个数的和
```

    6
    


```python
# 计算平均值
print(np.mean([1,2,3]))   # 结果是三个数的和的平均值
```

    2.0
    


```python
# 计算中位数  
# 奇数:排序后中间的数值
# 偶数:中间的两个数的平均值
print(np.median([1,2,8]))   # 简单理解的结果就是中间那个数
print(np.median([1,2,4,8]))   # 简单理解的结果就是中间两个数的平均值
```

    2.0
    3.0
    


```python
# 计算标准差，方差   这个没理解明白
# 方差的计算说明，1,2,3的平均值是2,((1-2)^2 + (2-2)^2 + (3-2)^2) / 3 = 0.6666666
# 
print(np.var([1,2,3]))   # 计算方差
print(np.std([1,2,3]))   # 计算标准差
arr = np.array([1,2,1,2,1,1,1,2])
arr1 = np.array([1,0,3,0,0,0,4,3])
print(np.mean(arr))   # 计算平均值
print(np.mean(arr1))  # 计算平均值
print(np.var(arr))    # 计算方差，就能看出区别了
print(np.var(arr1))   # 计算方差，就能看出区别了
```

    0.6666666666666666
    0.816496580927726
    1.375
    1.375
    0.234375
    2.484375
    


```python
# 计算最大值，最小值
arr = np.random.randint(1,200,8)
print(arr)
print(np.max(arr))  # 计算最大值
print(np.min(arr))  # 计算最小值
print(np.max(arr),np.argmax(arr))  # 计算最大值并找到索引位置在第几个
print(np.min(arr),np.argmin(arr))  # 计算最小值并找到索引位置在第几个
```

    [ 45  34 170  51 158 127 166  95]
    170
    34
    170 2
    34 1
    


```python
# 分位数   稍微绕一点，需要多理解
np.random.seed(0)  # 随机数
arr = np.random.randint(0,100,4)  # 随机数位0-100的其中4个数
print(arr)   
```

    [44 47 64 67]
    


```python
# ---------------   可以理解为0-100的轴
# 44  47   64  67
print(np.median(arr))  # 计算上面得出的4个数的中位数
print(np.percentile(arr,50))   # 计算上面得出的4个数的50%那个数
print(np.percentile(arr,25))   # 计算上面得出的4个数的50%那个数
"""
0.25*3=0.75
(47-44)*0.75=2.25+44=46.25
"""
```

    55.5
    55.5
    46.25
    




    '\n0.25*3=0.75\n(47-44)*0.75=2.25+44=46.25\n'




```python
# 累积和  累积积(乘法)
arr = np.array([2,5,3])   
print(np.sum(arr))    # 结果是三个数加起来的和
print(np.cumsum(arr))  # 结果是第一个元素是2，第二个元素是第一个加第二个，第三个元素是第一个加第二个加第三个的和
print(np.cumprod(arr))  # # 结果是第一个元素是2，第二个元素是第一个乘以第二个，第三个元素是第一个乘以第二个乘以第三个的积
```

    10
    [ 2  7 10]
    [ 2 10 30]
    

## 3.比较函数
## 比较是否大于、小于、等于逻辑与、或、非检查数组中是否有一个True，是否所有的都为True，自定义条件


```python
# 是否大于
print(np.greater([3,4,5,6,7,],4))  # 判断是否大于4,挨个比较出结果
# 是否小于
print(np.less([3,4,5,6,7],4))      # 判断是否小于4,挨个比较出结果
# 是否等于
print(np.equal([3,4,5,6,7],4))     # 判断是否等于于4,挨个比较出结果
print(np.equal([3,4,5],[4,4,4,]))  # 两个数组比较是否等于，按照对应位置比较
```

    [False False  True  True  True]
    [ True False False False False]
    [False  True False False False]
    [False  True False]
    


```python
# 逻辑与、或、非 本小结难理解一点，感觉有点抽象
# 逻辑与的运算
print(np.logical_and([0,0],[1,1]))
# 逻辑或
print(np.logical_or([0,0],[1,1]))  # 只要有一个是真的就是真，两个假才是假
# 逻辑非
print(np.logical_not([1,0]))
```

    [False False]
    [ True  True]
    [False  True]
    


```python
# 检查元素是否至少有一个元素为True
print(np.any([0,0,0,0,0,0])) 
# 检查是否全部元素为True
print(np.all([0,0,0,0,0,0]))  
```

    False
    False
    


```python
# 自定义条件
# print(np.where("条件","符合条件","不符合条件"))
arr = np.array([1,2,3,4,5])
print(np.where(arr < 3,arr,0))   # 判断arr是否小于3
# 举例
arr = np.array([1,2,3,4,5])
print(np.where(arr < 3,1,0))   # 判断arr是否小于3,小于的话1代表，不小于的0代表
# 举例 
score = np.random.randint(50,100,20)
print(score)
print(np.where(score >=60,'及格','不及格'))  # 判断以上的数，大于等于60的，用及格表示，其他的用不及格表示

```

    [1 2 0 0 0]
    [1 1 0 0 0]
    [53 89 59 69 71 86 73 56 74 74 62 51 88 89 73 96 74 67 87 75]
    ['不及格' '及格' '不及格' '及格' '及格' '及格' '及格' '不及格' '及格' '及格' '及格' '不及格' '及格' '及格'
     '及格' '及格' '及格' '及格' '及格' '及格']
    


```python
score1 = np.random.randint(50,100,20)
print(score1)
# 判断以上的数，小于于60的，用不及格表示，小于80的用良好，其他的用优秀，属于嵌套
print(np.where(score1 < 60,'不及格',np.where(score1 < 80,'良好','优秀')))
# 另外一种跟嵌套差不多的，稍微简单一点
# np.select(条件，返回的结果)
print(np.select([score1 > 80,(score1 >= 60) & (score1 <= 80),score1 < 60],['优秀','良好','不及格'],default='未知'))

```

    [63 58 59 70 66 55 65 97 50 68 85 74 99 79 69 69 64 89 82 51]
    ['良好' '不及格' '不及格' '良好' '良好' '不及格' '良好' '优秀' '不及格' '良好' '优秀' '良好' '优秀' '良好'
     '良好' '良好' '良好' '优秀' '优秀' '不及格']
    ['良好' '不及格' '不及格' '良好' '良好' '不及格' '良好' '优秀' '不及格' '良好' '优秀' '良好' '优秀' '良好'
     '良好' '良好' '良好' '优秀' '优秀' '不及格']
    


```python
# 排序函数
np.random.seed(0)
arr = np.random.randint(1,100,20)
print(arr)       # 打印结果1-100的任意数字，取20个
print(np.sort(arr))  # 用这个不改变原始数组也可以简化一点
print(np.argsort(arr))   # 打印排序后的索引在元素数组的什么位置
```

    [45 48 65 68 68 10 84 22 37 88 71 89 89 13 59 66 40 88 47 89]
    [10 13 22 37 40 45 47 48 59 65 66 68 68 71 84 88 88 89 89 89]
    [ 5 13  7  8 16  0 18  1 14  2 15  3  4 10  6  9 17 11 12 19]
    


```python
# 去重函数
np.random.seed(0)
arr = np.random.randint(1,100,20)
print(arr)   # 打印结果1-100的任意数字，取20个
print(np.unique(arr))  # 打印上面获得的函数去掉重复的函数，然后进行排序
```

    [45 48 65 68 68 10 84 22 37 88 71 89 89 13 59 66 40 88 47 89]
    [10 13 22 37 40 45 47 48 59 65 66 68 71 84 88 89]
    


```python
# 数组的拼接
arr1 = np.array([1,2,3])
arr2 = np.array([4,5,6])
print(arr1 + arr2)
print(np.concatenate((arr1,arr2)))   # 直接首尾拼接
```

    [5 7 9]
    [1 2 3 4 5 6]
    


```python
# 数组的切割
np.random.seed(0)
arr = np.random.randint(1,100,20)
print(np.split(arr,4))   # 把结果切割为4分
print(np.split(arr,[6,11,18]))   # 把索引元素为6的切一刀，然后是把索引为11的切一刀，最后是把索引为18的切一刀，最后剩下的2个是什么元素

```

    [array([45, 48, 65, 68, 68], dtype=int32), array([10, 84, 22, 37, 88], dtype=int32), array([71, 89, 89, 13, 59], dtype=int32), array([66, 40, 88, 47, 89], dtype=int32)]
    [array([45, 48, 65, 68, 68, 10], dtype=int32), array([84, 22, 37, 88, 71], dtype=int32), array([89, 89, 13, 59, 66, 40, 88], dtype=int32), array([47, 89], dtype=int32)]
    


```python
# 调整数组的形状
np.random.seed(0)
arr = np.random.randint(1,100,20)
print(np.reshape(arr,[4,5]))  # 把数组结果调整为4行5列，必须保证数组的数够分才行，要不然报错
```

    [[45 48 65 68 68]
     [10 84 22 37 88]
     [71 89 89 13 59]
     [66 40 88 47 89]]
    

# 1-3.总结
## Numpy介绍
### Numpy是Python中科学计算的基础包。
它是一个Python库，提供多维数组对象、各种派生对象（例如掩码数组和矩阵）以及用于
对数组进行快速操作的各种方法，包括数学、逻辑、形状操作、排序、选择、I/O、离散
傅里叶变换、基本线性代数、基本统计运算、随机模拟等等。
numpy的部分功能如下：
ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。
用于对整组数据进行快速运算的标准数学函数（无需编写循环）。
用于读写磁盘数据的工具以及用于操作内存映射文件的工具。
线性代数、随机数生成以及傅里叶变换功能。
用于集成由C、C++、Fortran等语言编写的代码的API。

### Numpy数组(ndarray)的核心特性
多维性：支持0维（标量）、1维（向量）、2维（矩阵）及更高维数组。
同质性：所有元素类型必须一致（通过dtype指定）。
高效性：基于连续内存块存储，支持向量化运算。

### ndarry的属性
| 属性名称 | 通俗解释 | 使用示例 |
|---------|---------|---------|
| shape | 数组的形状：行数和列数（或更高维度的尺寸） | `arr.shape` |
| ndim | 维度数量：数组是几维的（1维、2维、3维等） | `arr.ndim` |
| size | 总元素个数：数组中所有元素的总数 | `arr.size` |
| dtype | 元素类型：数组中元素的类型（整数、浮点数等） | `arr.dtype` |
| T | 转置：行变列，列变行 | `arr.T` |
| itemsize | 单个元素占用的内存字节数 | `arr.itemsize` |
| nbytes | 数组总内存占用量：size × itemsize | `arr.nbytes` |
| flags | 内存存储方式：是否连续存储（高级优化） | `arr.flags` |

### ndarray的创建
1.基础构造：适用于手动构建小规模数组或复制已有数据。
2.预定义形状填充：用于快速初始化固定形状的数组（如全0占位、全1初始化）。
3.基于数值范围生成：生成数值序列，常用于模拟时间序列、坐标网格等。
4.特殊矩阵生成：数学运算专用（如线性代数中的单位矩阵）。
5.随机数组生成：模拟实验数据、初始化神经网络权重等场景。
6.高级构造方法：处理非结构化数据（如文件、字符串）或通过函数生成复杂数组。

| 用途 | 方法1 | 方法2 | 方法3 | 方法4 |
|------|-------|-------|-------|-------|
| **基础构造** | `np.array()` | `np.copy()` | - | - |
| **预定义形状填充** | `np.zeros()` | `np.ones()` | `np.empty()` | `np.full()` |
| **基于数值范围生成** | `np.arange()` | `np.linspace()` | `np.logspace()` | - |
| **特殊矩阵生成** | `np.eye()` | `np.diag()` | - | - |
| **随机数组生成** | `np.random.rand()` | `np.random.randn()` | `np.random.randint()` | - |
| **高级构造方法** | `np.array()` | `np.loadtxt()` | `np.fromfunction()` | - |

### ndarray的矩阵
| 名称 | 维度 | 示例 | 备注 |
|------|------|------|------|
| 标量 | 0维 | `5, 3.14` | 单个数字，无行列 |
| 向量 | 1维 | `[1, 2, 3]` | 只有行或列（一维数组） |
| 矩阵 | 2维 | `[[1, 2], [3, 4]]` | 严格的行列结构（二维表） |
| 张量 | ≥3维 | `[[[1, 2], [3, 4]]]` | 高阶数组（如RGB图像） |

| 概念 | 说明 | 示例 |
|------|------|------|
| **定义** | 矩阵是一个由行（row）和列（column）排列成的矩形数组 | $A = \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}$ |
| **形状（shape）** | 这个矩阵有2行3列，记作2×3矩阵 | 2行 × 3列 |
| **元素（entry）** | 矩阵中的每个数字称为元素 | 1, 2, 3, 4, 5, 6 |

#### ndarray的特殊矩阵
| 矩阵类型 | 定义 | 例子 |
|----------|------|------|
| 零矩阵 | 所有元素为0 | $\begin{bmatrix}0 & 0 \\0 & 0\end{bmatrix}$ |
| 单位矩阵 | 对角线上为1，其余为0 | $\begin{bmatrix}1 & 0 \\0 & 1\end{bmatrix}$ |
| 对角矩阵 | 只有对角线有非零值 | $\begin{bmatrix}2 & 0 \\0 & 3\end{bmatrix}$ |
| 对称矩阵 | $A = A^{T}$ | $\begin{bmatrix}1 & 2 \\2 & 3\end{bmatrix}$ |

### ndarray的数据类型
| 数据类型 | 说明 |
|---------|------|
| bool | 布尔类型 |
| int8、uint8 | 有符号、无符号的8位（1字节）整型 |
| int16、uint16 | 有符号、无符号的16位（2字节）整型 |
| int32、uint32 | 有符号、无符号的32位（4字节）整型 |
| int64、uint64 | 有符号、无符号的64位（8字节）整型 |
| float16 | 半精度浮点型 |
| float32 | 单精度浮点型 |
| float64 | 双精度浮点型 |
| complex64 | 用两个32位浮点数表示的复数 |
| complex128 | 用两个64位浮点数表示的复数 |

### 索引与切片
| 索引/切片类型 | 描述/用法                              |
|--------------|------------------------------------|
| 基本索引 | 通过整数索引直接访问元素。索引从0开始。               |
| 行/列切片 | 使用冒号`:`切片语法选择行或列的子集。               |
| 连续切片 | 从起始索引到结束索引按步长切片。                   |
| 使用slice函数 | 通过`slice(start, stop, step)`定义切片规则。 |
| 布尔索引 | 通过布尔条件筛选满足条件的元素。支持逻辑运算符`&`、`       |`。 |

### Numpy常用函数
| 基本数学 | 统计 | 比较 | 其他 |
|---------|------|------|------|
| `np.sqrt(x)` | `np.sum(x)` | `np.greater(a, b)` | `np.concatenate((a, b))` |
| `np.exp(x)` | `np.mean(x)` | `np.less(a, b)` | `np.split(x, indices)` |
| `np.log(x)` | `np.median(x)` | `np.equal(a, b)` | `np.reshape(x, shape)` |
| `np.sin(x)` | `np.std(x)` | `np.logical_and(a, b)` | `np.copy(x)` |
| `np.abs(x)` | `np.var(x)` | `np.where(condition, x, y)` | `np.isnan(x)` |
| `np.power(a, b)` | `np.min(x) / np.max(x)` | **去重** | **排序** |
| `np.round(x, n)` | `np.percentile(x, q)` | `np.unique(x)` | `np.sort(x)` |
| | | `np.in1d(a, b)` | `np.argsort(x)` |
| | | | `np.lexsort(keys)` |

# 1-4.Numpy科学计算综合练习
#### 题目  1：温度数据分析
某城市一周的最高气温(30°C)为[28,30,29,31,32,30,29]
- 计算平均气温、最高气温和最低气温。
- 找出气温超过30°C的天数。


```python
import numpy as np
temps = np.array([28,30,29,31,32,30,29])
print('一周的气温:',temps)
print('平均气温:','%.2f' % np.mean(temps))  # 计算平均气温，'%.3f'表示保留2位小数
print('最高气温:',np.max(temps))     # 计算最高气温
print('最低气温:',np.min(temps))     # 计算最低气温
print('气温超过30度的天数:',len(temps[temps > 30]))   # 计算超过30度的天数，就是找到大于30的天数，数组的长度是len
print('气温超过30度的天数:',np.where(temps > 30,temps,0))   # 查找大于30度的天，符号的用temps表示，不符合的用0表示
```

    一周的气温: [28 30 29 31 32 30 29]
    平均气温: 29.86
    最高气温: 32
    最低气温: 28
    气温超过30度的天数: 2
    气温超过30度的天数: [ 0  0  0 31 32  0  0]
    

#### 题目2：学生的成绩统计
某班级5名学生的数学成绩为[85,90,78,92,88].
-计算成绩的平均分、中位数和标准差。
将成绩转换为百分制(假设满分为 100)。


```python
score = np.array([85,90,78,92,88])
print(score)
print(np.sort(score))    # 排序
print('平均分',np.mean(score))   # 计算平均分
print('中位数',np.median(score))  # 找到中位数
print('标准差:%.2f'% np.std(score))    # 计算标准差，保留两位数
```

    [85 90 78 92 88]
    [78 85 88 90 92]
    平均分 86.6
    中位数 88.0
    标准差:4.88
    

#### 题目3：矩阵运算
给定矩阵 A = [[1,2],[3,4]]和 B = [[5,6],[7,8]].
- 计算 A + B 和 A * B(逐元素乘法)。
- 计算 A 和 B 的矩阵乘法(点积)。


```python
A = np.array([[1,2],[3,4]])
B = np.array([[5,6],[7,8]])
print(A + B)   # 加法
print(A * B)   # 乘法
print(A @ B)   # 点积
print(np.dot(A,B))  # 针对点积的说明
"""
   A         B
| 1 2 |   | 5 6 |
| 3 4 |   | 7 8 |
19 = A[1:]*B[:1] = (1 2)*(5 7) = 1*5 +2*7 = 19  # A的第一行乘以B的第一列，也就是A的1 2乘以B的5 7，列式就是1*5+2*7=19
22 = A[1:]*B[:2] = (1 2)*(6 8) = 1*6 +2*8 = 22  # A的第一行乘以B的第二列，也就是A的1 2乘以B的6 8，列式就是1*6+2*8=22
43 = A[2:]*B[:1] = (3 5)*(5 7) = 3*5 +4*7 = 43  # A的第二行乘以B的第一列，也就是A的3 4乘以B的5 7，列式就是3*5+4*7=43
50 = A[2:]*B[:5] = (3 4)*(6 8) = 3*6 +4*8 = 50  # A的第二行乘以B的第二行，也就是A的3 4乘以B的6 8，列式就是3*6+4*8=50
"""
```

    [[ 6  8]
     [10 12]]
    [[ 5 12]
     [21 32]]
    [[19 22]
     [43 50]]
    [[19 22]
     [43 50]]
    




    '\n   A         B\n| 1 2 |   | 5 6 |\n| 3 4 |   | 7 8 |\n19 = A[1:]*B[:1] = (1 2)*(5 7) = 1*5 +2*7 = 19  # A的第一行乘以B的第一列，也就是A的1 2乘以B的5 7，列式就是1*5+2*7=19\n22 = A[1:]*B[:2] = (1 2)*(6 8) = 1*6 +2*8 = 22  # A的第一行乘以B的第二列，也就是A的1 2乘以B的6 8，列式就是1*6+2*8=22\n43 = A[2:]*B[:1] = (3 5)*(5 7) = 3*5 +4*7 = 43  # A的第二行乘以B的第一列，也就是A的3 4乘以B的5 7，列式就是3*5+4*7=43\n50 = A[2:]*B[:5] = (3 4)*(6 8) = 3*6 +4*8 = 50  # A的第二行乘以B的第二行，也就是A的3 4乘以B的6 8，列式就是3*6+4*8=50\n'



#### 题目4：随机数据生成
生成一个(3,4)的随机整数数组，范围[0,10].
- 计算每列的最大值和每行的最小值。
- 将数组中的所有奇数替换为 -1.


```python
np.random.seed(0)
arr = np.random.randint(0,10,(3,4))
print(arr)
print('每列的最大值:',np.max(arr,axis=0))    # 计算每列最大值，axis=0代表是列，
print('每列的最大值:',np.min(arr,axis=1))    # 计算每行最小值，axis=1代表是行
print(np.where(arr%2==1,-1,arr))      # 将数组中的所有奇数替换为-1，
```

    [[5 0 3 3]
     [7 9 3 5]
     [2 4 7 6]]
    每列的最大值: [7 9 7 6]
    每列的最大值: [0 3 2]
    [[-1  0 -1 -1]
     [-1 -1 -1 -1]
     [ 2  4 -1  6]]
    

#### 题目5-1:数组变形
创建一个1到12的一维数组，并转换(3,4)的二维数组。
- 计算每行的和与每列的平均值。
- 将数组展平为一维数组


```python
arr = np.arange(1,13)  # 创建1-12的数组，
print(arr)
print(np.reshape(arr,(3,4)))   # 转换为3行4列
arr = np.reshape(arr,(3,4))  # 先赋值给arr是3行4列
print('每行的和:',np.sum(arr,axis=1))
print('每列的平均值:',np.mean(arr,axis=0))
print(np.reshape(arr,(12)))   # 在把3行4列的二维数组，转换为一维数组
```

    [ 1  2  3  4  5  6  7  8  9 10 11 12]
    [[ 1  2  3  4]
     [ 5  6  7  8]
     [ 9 10 11 12]]
    每行的和: [10 26 42]
    每列的平均值: [5. 6. 7. 8.]
    [ 1  2  3  4  5  6  7  8  9 10 11 12]
    

#### 题目5-2：数组变形
生成一个(5,5)的随机数组，范围[0,20].
- 找出数组中大于10的元素
- 将所有大于10的元素替换为0


```python
np.random.seed(0)     # 把种子固定一下，就是随机的数组不会变
arr = np.random.randint(0,20,(5,5))
print(arr)
print(arr[arr > 10])   # 找到大于10的元素
arr[arr > 10 ] = 0     # 赋值arr大于10的元素替换为0
print(arr)
```

    [[12 15  0  3  3]
     [ 7  9 19 18  4]
     [ 6 12  1  6  7]
     [14 17  5 13  8]
     [ 9 19 16 19  5]]
    [12 15 19 18 12 14 17 13 19 16 19]
    [[0 0 0 3 3]
     [7 9 0 0 4]
     [6 0 1 6 7]
     [0 0 5 0 8]
     [9 0 0 0 5]]
    

#### 题目6:统计函数应用
某公司6个月的销售额(万元)为[120,135,110,125,130,140].
- 计算销售额的总和、平均值和方差。
- 找出销售额最高的月份和最低的月份。


```python
money = np.array([120,135,110,125,130,140])
print('总和:',np.sum(money))
print('平均值:',np.mean(money))
print('方差:',np.var(money))
print('最高月份:',np.argmax(money)+1)
print('最低的月份:',np.argmin(money)+1)
```

    总和: 760
    平均值: 126.66666666666667
    方差: 97.22222222222223
    最高月份: 6
    最低的月份: 3
    

#### 题目7:数组拼接
给定A = [1,2,3]和B = [4,5,6].
- 将A 和 B水平拼接为一个新数组。
- 将A 和 B垂直拼接为一个新数组。


```python
A = np.array([1,2,3])
B = np.array([4,5,6])
C = np.concatenate([A,B])   # 拼接A和B，不是相加
print(C)
print(np.reshape(C,(2,3)))   # 将A和B拼接为2行3列的新数组
```

    [1 2 3 4 5 6]
    [[1 2 3]
     [4 5 6]]
    

#### 题目8:唯一值与排序
给定数组[2,1,2,3,1,4,3].
- 找出数组中的唯一值并排序。
- 计算每个唯一值出现的次数。


```python
arr = np.array([2,1,2,3,1,4,3])
print(np.unique(arr))  # 找到唯一的值，也就是1,2,3,4
u_arr,counts = np.unique(arr,return_counts=True)   # 同时找到唯一值并排序，还有出现的次数
print(u_arr)   # 找到唯一的值，也就是1,2,3,4
print(counts)   # 出现的次数
```

    [1 2 3 4]
    [1 2 3 4]
    [2 2 2 1]
    

#### 题目9:综合应用
某商店5天的销售额(万元)和成本(万元)如下:
销售额:[20,25,22,30,28]
成本:[15,18,16,22,20]
- 计算每天的利润(销售额 - 成本)。
- 计算利润的平均值和标准差。
- 找出利润最高的天数。


```python
money = np.array([20,25,22,30,28])
a = np.array([15,18,16,22,20])
print('每天的利润:',money - a)   # 计算每天的利润就是相见就行
b = money - a
print('利润的平均值:',np.mean(b))
print('利润的标准差:',np.std(b))
print('利润最高的天数:',len(b[b==np.max(b)]))
```

    每天的利润: [5 7 6 8 8]
    利润的平均值: 6.8
    利润的标准差: 1.16619037896906
    利润最高的天数: 2
    


```python

```
